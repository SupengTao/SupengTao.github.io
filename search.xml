<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[表示数值的字符串]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 思路正则表达式 代码123function isNumeric(s) &#123; return s.match(/[+-]?\d*(\.\d*)?([eE][+-]?\d+)?/g)[0] === s;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数柯里化]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配。 思路1.js原生自带正则2.递归思路 当模式中的第二个字符不是“*”时： 1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。 2、如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 而当模式中的第二个字符是“*”时： 如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式： 1、模式后移2字符，相当于x被忽略； 2、字符串后移1字符，模式后移2字符； 3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为可以匹配多位； 代码1234567891011121314151617181920212223242526272829303132333435363738//方法1function match(s, pattern) &#123; const reg = new RegExp(`^$&#123;pattern&#125;$`); return reg.test(s);&#125;//方法2// 第二种function matchCore(s, istr, pattern, ipattern) &#123; if (istr === s.length &amp;&amp; ipattern === pattern.length) &#123; return true; &#125; if (istr !== s.length &amp;&amp; ipattern === pattern.length) &#123; return false; &#125; if (pattern[ipattern + 1] === '*') &#123; if (pattern[ipattern] === '.' &amp;&amp; istr !== s.length || pattern[ipattern] === s[istr]) &#123; return ( matchCore(s, istr + 1, pattern, ipattern + 2) || matchCore(s, istr + 1, pattern, ipattern) || matchCore(s, istr, pattern, ipattern + 2) ); &#125; return matchCore(s, istr, pattern, ipattern + 2); &#125; if (s[istr] === pattern[ipattern] || pattern[ipattern] === '.' &amp;&amp; istr !== s.length) &#123; return matchCore(s, istr + 1, pattern, ipattern + 1); &#125; return false;&#125;function match2(s, pattern) &#123; if (s === null || pattern === null) &#123; return false; &#125; return matchCore(s, 0, pattern, 0);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建乘积数组]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 思路借助中间变量存储后面的乘积 代码12345678910111213141516function multiply(array) &#123; const B = [], len = array.length; B[0] = 1; // 计算前i - 1个元素的乘积 for (let i = 1; i &lt; len; i++) &#123; B[i] = array[i - 1] * B[i - 1]; &#125; let tmp = 1; // 计算后N - i个元素的乘积并连接 for (let i = len - 2; i &gt;= 0; i--) &#123; tmp *= array[i + 1]; B[i] *= tmp; &#125; return B;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把字符串转化为整数]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 思路不能使用parseInt函数，要求自己实现，可以使用位运算 代码1234567891011121314function StrToInt(str) &#123; let res = 0, flag = 1; const n = str.length; if (!n) return 0; if (str[0] === '-') &#123; flag = -1; &#125; for (let i = str[0] === '+' || str[0] === '-' ? 1 : 0; i &lt; n; i++) &#123; if (!(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')) return 0; res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + (str[i] - '0'); &#125; return res * flag;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重复的数]]></title>
    <url>%2F2019%2F05%2F11%2F%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路利用map ，键值对应求解 代码1234567891011121314function duplicate(numbers, duplication) &#123; const map = &#123;&#125;; let flag = false; for (let i = 0; i &lt; numbers.length; i++) &#123; if (!map[numbers[i]]) &#123; map[numbers[i]] = 1; &#125; else &#123; duplication[0] = numbers[i]; flag = true; break; &#125; &#125; return flag;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F05%2F11%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 思路二进制、位运算 代码12345678function Add(num1, num2) &#123; while (num2 !== 0) &#123; const tmp1 = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = tmp1; &#125; return num1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算题]]></title>
    <url>%2F2019%2F05%2F11%2F%E8%AE%A1%E7%AE%97%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 思路位运算+递归 代码123function SumSolution(n) &#123; return n &amp;&amp; Sum_Solution(n - 1) + n;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[孩子们的游戏]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 思路约瑟夫环问题 代码1234567891011121314function LastRemainingSolution(n, m) &#123; if (n === 0 || m === 0) return -1; const child = []; let del = 0; for (let i = 0; i &lt; n; i++) &#123; child[i] = i; &#125; while (child.length &gt; 1) &#123; const k = m - 1; del = (del + k) % child.length; child.splice(del, 1); &#125; return child[0];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扑克牌游戏]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%89%91%E5%85%8B%E7%89%8C%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。 思路要求是顺子，则要求5个数最大最小数的差不超过5，且不能有重复的数字 代码12345678910111213141516function IsContinuous(numbers) &#123; let max = 0, min = 14, flag = 0; if (numbers.length !== 5) return false; for (let i = 0; i &lt; numbers.length; i++) &#123; if (numbers[i] &gt; 13 || numbers[i] &lt; 0) return false; if (numbers[i] === 0) continue; if ((flag &gt;&gt; numbers[i] &amp; 1) === 1) return false; flag = flag | 1 &lt;&lt; numbers[i]; if (numbers[i] &gt; max) max = numbers[i]; if (numbers[i] &lt; min) min = numbers[i]; &#125; if (max - min &gt;= 5) return false; return true;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转单词序列]]></title>
    <url>%2F2019%2F05%2F08%2F%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am astudent.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路js直接调api 代码123456function ReverseSentence(str) &#123; return str .split(' ') .reverse() .join(' ');&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串左旋]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A6%E6%97%8B%2F</url>
    <content type="text"><![CDATA[题目汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路js的话直接调用splice函数就行了 代码12345function LeftRotateString(str, n) &#123; if (str === null || str.length === 0) return ''; n = n % str.length; return str.slice(n) + str.slice(0, n);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为s的字符串]]></title>
    <url>%2F2019%2F05%2F07%2F%E9%80%92%E5%A2%9E%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BAs%2F</url>
    <content type="text"><![CDATA[题目输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 思路数学题，和相同的乘积最小，画函数，两个数的相距距离最远即可 代码1234567891011121314151617function FindNumbersWithSum(array, sum) &#123; if (array.length &lt; 2) return []; let left = 0, right = array.length - 1; const res = []; while (left &lt; right) &#123; if (array[left] + array[right] &lt; sum) &#123; left++; &#125; else if (array[left] + array[right] &gt; sum) &#123; right--; &#125; else &#123; res.push(array[left], array[right]); break; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为s的连续正数序列]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 思路数学思路：假设序列的开始数字为a,结束数字为a+i，那么有(a+i-a+1)*(a+a+i)/2=sum只需要找到a,i就可以找到序列 代码123456789101112131415161718192021222324252627282930function FindContinuousSequence(sum) &#123; let a = 0, half = sum &gt;&gt; 1; const res = []; while (half--) &#123; a++; let i = 1; while ((i + 1) * (2 * a + i) &lt; 2 * sum) &#123; i++; &#125; if ((i + 1) * (2 * a + i) === 2 * sum) &#123; const tmp = []; tmp.push(a); tmp.push(i); res.push(tmp); &#125; &#125; for (let i = 0; i &lt; res.length; i++) &#123; let num = res[i][1], k = 1; const tmp = []; tmp.push(res[i][0]); while (num--) &#123; tmp.push(res[i][0] + k); k++; &#125; res[i] = tmp; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中只出现一次的数]]></title>
    <url>%2F2019%2F05%2F06%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路使用map记录下每个数的次数，占空间。 代码123456789101112131415161718function FindNumsAppearOnce(array) &#123; const map = &#123;&#125;, res = []; for (let i = 0; i &lt; array.length; i++) &#123; if (!map[array[i]]) &#123; map[array[i]] = 1; &#125; else &#123; map[array[i]]++; &#125; &#125; for (let i = 0; i &lt; array.length; i++) &#123; if (map[array[i]] === 1) &#123; res.push(array[i]); &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路递归判断左右子树相差为多少 代码123456789101112function IsBalanced_Solution(pRoot) &#123; if (pRoot == null) return true; let leftLen = TreeDepth(pRoot.left); let rightLen = TreeDepth(pRoot.right); return Math.abs(rightLen - leftLen) &lt;= 1 &amp;&amp; IsBalanced_Solution(pRoot.left) &amp;&amp; IsBalanced_Solution(pRoot.right);&#125;function TreeDepth(pRoot) &#123; if (pRoot == null) return 0; let leftLen = TreeDepth(pRoot.left); let rightLen = TreeDepth(pRoot.right); return Math.max(leftLen, rightLen) + 1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解call、apply]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3call%E3%80%81apply%2F</url>
    <content type="text"><![CDATA[call的概念1call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 例如123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 注意两点： 1.call 改变了 this 的指向，指向到 foo 2.bar 函数执行了 模拟第一版 12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;;foo.bar(); // 1 然而添加了新的属性，所以还需删除新方法实现结果如下123456789101112131415161718// 第一版Function.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call2(foo); // 1 模拟最终版本1.函数具有返回值2.this 参数可以传 null，当为 null 的时候，视为指向 window 实现方法如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125;// 测试一下var value = 2;var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call2(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 同理实现apply12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; 参考链接]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
        <tag>上下文this相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的深度]]></title>
    <url>%2F2019%2F05%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路递归遍历二叉树的深度为左右子树深度大的那一个 代码123456function TreeDepth(pRoot) &#123; if (pRoot === null) return 0; const leftDep = TreeDepth(pRoot.left); const rightDep = TreeDepth(pRoot.right); return Math.max(leftDep, rightDep) + 1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字在排序数组中出现的次数]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目统计一个数字在排序数组中出现的次数。 思路二分查找找到数字开始的位置和数字结束的位置，然后相减 代码12345678910111213141516171819202122232425262728293031323334function GetNumberOfK(data, k) &#123; if (getEnd(data, k) === -1 &amp;&amp; getBegin(data, k) === -1) return 0; return getEnd(data, k) - getBegin(data, k) + 1;&#125;function getBegin(data, k) &#123; let [left, right] = [0, data.length - 1]; let mid = left + right &gt;&gt; 1; while (left &lt;= right) &#123; if (data[mid] &gt; k) &#123; right = mid - 1; &#125; else if (data[mid] &lt; k) &#123; left = mid + 1; &#125; else if (mid - 1 &gt;= 0 &amp;&amp; data[mid - 1] === k) &#123; right = mid - 1; &#125; else return mid; mid = left + right &gt;&gt; 1; &#125; return -1;&#125;function getEnd(data, k) &#123; let [left, right] = [0, data.length - 1]; let mid = left + right &gt;&gt; 1; while (left &lt;= right) &#123; if (data[mid] &gt; k) &#123; right = mid - 1; &#125; else if (data[mid] &lt; k) &#123; left = mid + 1; &#125; else if (mid + 1 &lt; data.length &amp;&amp; data[mid + 1] === k) &#123; left = mid + 1; &#125; else return mid; mid = left + right &gt;&gt; 1; &#125; return -1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两链表的公共节点]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%B8%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目输入两个链表，找出它们的第一个公共结点。 思路快慢指针 代码1234567891011121314151617181920212223242526272829303132function FindFirstCommonNode(pHead1, pHead2) &#123; const len1 = getLinkLength(pHead1), len2 = getLinkLength(pHead2); let pLong = pHead1, pShort = pHead2, lenGap = len1 - len2; if (len1 &lt; len2) &#123; pLong = pHead2; pShort = pHead1; lenGap = len2 - len1; &#125; while (lenGap--) &#123; pLong = pLong.next; &#125; while (pLong !== null) &#123; // pLong,pShort一起跑 if (pLong.val === pShort.val) &#123; return pLong; &#125; pLong = pLong.next; pShort = pShort.next; &#125; return null;&#125;function getLinkLength(pHead) &#123; let length = 0; while (pHead !== null) &#123; pHead = pHead.next; length++; &#125; return length;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中的逆序对]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 思路归并排序的思路 先把数组分隔成子数组， 先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。 代码1234567891011121314151617181920212223242526272829function InversePairs(data) &#123; if (!data || data.length &lt; 2) return 0; const copy = data.slice(); let count = 0; count = mergeCount(data, copy, 0, data.length - 1); return count % 1000000007;&#125;function mergeCount(data, copy, start, end) &#123; if (start === end) return 0; const mid = end - start &gt;&gt; 1, left = mergeCount(copy, data, start, start + mid), // 注意参数，copy作为data传入 right = mergeCount(copy, data, start + mid + 1, end); // 注意参数，copy作为data传入 let [p, q, count, copyIndex] = [start + mid, end, 0, end]; while (p &gt;= start &amp;&amp; q &gt;= start + mid + 1) &#123; if (data[p] &gt; data[q]) &#123; copy[copyIndex--] = data[p--]; count = count + q - start - mid; &#125; else &#123; copy[copyIndex--] = data[q--]; &#125; &#125; while (p &gt;= start) &#123; copy[copyIndex--] = data[p--]; &#125; while (q &gt;= start + mid + 1) &#123; copy[copyIndex--] = data[q--]; &#125; return count + left + right;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个只出现一次的字符]]></title>
    <url>%2F2019%2F05%2F01%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置 思路使用map来记录字符出现的次数即可 代码1234567891011121314151617function FirstNotRepeatingChar(str) &#123; if (str.length &lt; 1 || str.length &gt; 10000) return -1; const map = &#123;&#125;; for (let i = 0; i &lt; str.length; i++) &#123; if (!map[str[i]]) &#123; map[str[i]] = 1;//未出现过则map次数为1 &#125; else &#123; map[str[i]]++;//出现过则次数在加一 &#125; &#125; for (let i = 0; i &lt; str.length; i++) &#123; if (map[str[i]] === 1) &#123; return i;//找到出现次数第一个为一的字符 &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丑数]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路动态规划 把前面的丑数存着，生成后面的丑数。t2,t3,t5是判断点，用于判断从何处开始选出并乘以对应因子肯定会大于当前数组中最大丑数，而前面的丑数不用考虑。 代码123456789101112function GetUglyNumber_Solution(index) &#123; if (index === 0) return 0; var uglyNum = [1]; var factor2 = 0, factor3 = 0, factor5 = 0; for (var i = 1; i &lt; index; i++) &#123; uglyNum[i] = Math.min(uglyNum[factor2] * 2, uglyNum[factor3] * 3, uglyNum[factor5] * 5); if (uglyNum[i] === uglyNum[factor2] * 2) factor2++; if (uglyNum[i] === uglyNum[factor3] * 3) factor3++; if (uglyNum[i] === uglyNum[factor5] * 5) factor5++; &#125; return uglyNum[index - 1];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾经的博客地址]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%9B%BE%E7%BB%8F%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[博客地址]]></content>
      <categories>
        <category>以前的博客</category>
      </categories>
  </entry>
</search>
