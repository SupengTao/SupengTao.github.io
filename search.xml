<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据流中的中位数]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 思路思路没什么好说的，主要拓展在不同情况下的不同数据结构，进行操作时的不同复杂度，寻找最优解 代码12345678910111213const array = [];function Insert(num) &#123; array.push(num); for (let i = array.length - 2; array[i] &gt; num; i--) &#123; [array[i], array[i + 1]] = [array[i + 1], array[i]]; &#125;&#125;function GetMedian() &#123; if (array.length &amp; 1 === 1) &#123; return array[(array.length - 1) / 2]; &#125; return (array[array.length / 2] + array[array.length / 2 - 1]) / 2;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的第k个节点]]></title>
    <url>%2F2019%2F05%2F27%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 思路二叉搜索树的中序遍历即为从小到大排列 代码1234567891011121314151617181920212223function KthNode(pRoot, k) &#123; if (pRoot === null || k === 0) &#123; return null; &#125; // 为了能追踪k，应该把KthNodeCore函数定义在这里面，k应该在KthNodeCore函数外面 function KthNodeCore(pRoot) &#123; let target = null; if (pRoot.left !== null) &#123; target = KthNodeCore(pRoot.left, k); &#125; if (target === null) &#123; if (k === 1) &#123; target = pRoot; &#125; k--; &#125; if (target === null &amp;&amp; pRoot.right !== null) &#123; target = KthNodeCore(pRoot.right, k); &#125; return target; &#125; return KthNodeCore(pRoot);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化二叉树]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目请实现两个函数，分别用来序列化和反序列化二叉树 思路序列化二叉树即将二叉树转化为字符串形式（前中后序），需要注意将空节点标识出来，反序列化需要注意标识是否为空节点 代码12345678910111213141516171819202122232425const arr = [];function Serialize(pRoot) &#123; // write code here if (pRoot === null) &#123; arr.push('a'); &#125; else &#123; arr.push(pRoot.val); Serialize(pRoot.left); Serialize(pRoot.right); &#125;&#125;function Deserialize() &#123; // write code here let node = null; if (arr.length &lt; 1) &#123; return null; &#125; const number = arr.shift(); if (typeof number === 'number') &#123; node = new TreeNode(number); node.left = Deserialize(); node.right = Deserialize(); &#125; return node;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按层打印二叉树]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路记录上一层的子节点个数，才能按个数分行，引入一个辅助队列 代码12345678910111213141516171819202122232425262728293031function Print(pRoot) &#123; const queue = [], res = []; if (pRoot === null) &#123; return res; &#125; queue.push(pRoot); let nextLevel = 0; // 下一层节点个数 let toBePrinted = 1; // 这一层还有多少个节点要打印 let list = []; // 存放每一层节点 while (queue.length) &#123; const pNode = queue.shift(); list.push(pNode.val); if (pNode.left !== null) &#123; queue.push(pNode.left); nextLevel++; &#125; if (pNode.right !== null) &#123; queue.push(pNode.right); nextLevel++; &#125; toBePrinted--; if (toBePrinted === 0) &#123; res.push(list); list = []; toBePrinted = nextLevel; nextLevel = 0; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[之字形打印二叉树]]></title>
    <url>%2F2019%2F05%2F25%2F%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 思路画图分析，使用两个栈进行操作 代码12345678910111213141516171819202122232425262728293031323334353637383940function Print(pRoot) &#123; const lists = []; if (pRoot === null) &#123; return lists; &#125; const stack1 = []; const stack2 = []; stack2.push(pRoot); let i = 1; while (stack1.length !== 0 || stack2.length !== 0) &#123; const list = []; // 为奇数层 if ((i &amp; 1) === 1) &#123; while (stack2.length !== 0) &#123; const tmp = stack2[stack2.length - 1]; stack2.pop(); list.push(tmp.val); if (tmp.left !== null) stack1.push(tmp.left); if (tmp.right !== null) stack1.push(tmp.right); &#125; &#125; // 为偶数层 else &#123; while (stack1.length !== 0) &#123; const tmp = stack1[stack1.length - 1]; stack1.pop(); list.push(tmp.val); if (tmp.right !== null) stack2.push(tmp.right); if (tmp.left !== null) stack2.push(tmp.left); &#125; &#125; ++i; lists.push(list); &#125; return lists; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称的二叉树]]></title>
    <url>%2F2019%2F05%2F24%2F%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路与树相关的常用递归的思路来解决 代码123456789101112131415161718function isSymmetrical(pRoot) &#123; if (pRoot === null) &#123; return true; &#125; return compareRoot(pRoot.left, pRoot.right);&#125;function compareRoot(left, right) &#123; if (left === null) &#123; return right === null; &#125; if (right === null) &#123; return false; &#125; if (left.val !== right.val) &#123; return false; &#125; return compareRoot(left.left, right.right) &amp;&amp; compareRoot(left.right, right.left);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一个节点]]></title>
    <url>%2F2019%2F05%2F22%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路绘图分析，状态考虑全面即可 代码123456789101112131415161718192021function GetNext(pNode) &#123; if (pNode === null) &#123; return null; &#125; if (pNode.right !== null) &#123; // 第1种 pNode = pNode.right; while (pNode.left !== null) &#123; pNode = pNode.left; &#125; return pNode; &#125; while (pNode.next !== null) &#123; // 第2种 if (pNode === pNode.next.left) &#123; return pNode.next; &#125; pNode = pNode.next; &#125; return null;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除链表中重复的节点]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 思路注意两点：1.第一第二个节点重复需要额外创建新的头结点2.多个重复节点需要循环处理 代码12345678910111213141516171819202122232425262728293031323334353637383940function deleteDuplication(pHead)&#123; if(!pHead)&#123; return null; &#125; var tempHead = new ListNode(-1); tempHead.next = pHead; var preNode = tempHead; var curr1 = preNode.next; var curr2 = curr1.next; while(curr1)&#123; if(!curr2 || curr2.val !== curr1.val)&#123; if(curr1.next !== curr2)&#123; clear(curr1, curr2); preNode.next = curr2; &#125; else &#123; preNode = curr1; &#125; curr1 = curr2; if(curr2)&#123; curr2 = curr2.next; &#125; &#125; else &#123; if(curr2)&#123; curr2 = curr2.next; &#125; &#125; &#125; return tempHead.next; function clear(node, stop)&#123; var temp; while(node !== stop)&#123; temp = node.next; node.next = null; node = temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表中环的入口节点]]></title>
    <url>%2F2019%2F05%2F21%2F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路快慢指针 代码123456789101112131415161718function EntryNodeOfLoop(pHead) &#123; let fast = pHead; let slow = pHead; while (fast !== null &amp;&amp; fast.next !== null) &#123; slow = slow.next; fast = fast.next.next; if (fast === slow) &#123; // 两者相遇 let p = pHead; while (p !== slow) &#123; p = p.next; slow = slow.next; &#125; return p; &#125; &#125; return null;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流中第一个不重复的字符]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 思路用map来解决 代码12345678910111213141516171819let map = &#123;&#125;;function Init() &#123; map = &#123;&#125;;&#125;function Insert(ch) &#123; if (map[ch]) &#123; map[ch] += 1; &#125; else &#123; map[ch] = 1; &#125;&#125;function FirstAppearingOnce() &#123; for (const i in map) &#123; if (map[i] === 1) &#123; return i; &#125; &#125; return '#';&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表示数值的字符串]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 思路正则表达式 代码123function isNumeric(s) &#123; return s.match(/[+-]?\d*(\.\d*)?([eE][+-]?\d+)?/g)[0] === s;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数的防抖和节流]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖定义： 合并事件且不会去触发事件，当一定时间内没有触发这个事件时，才真正去触发事件。 原理：对处理函数进行延时操作，若设定的延时到来之前，再次触发事件，则清除上一次的延时操作定时器，重新定时。 场景： keydown事件上验证用户名，输入法的联想。12345678910111213function debounce(fn, delay) &#123; var timer return function () &#123; var that = this var args = arguments clearTimeout(timer) timer = setTimeout(function () &#123; fn.apply(that, args) &#125;, delay) &#125;&#125; 节流定义： 持续触发事件时，合并一定时间内的事件，在间隔一定时间之后再真正触发事件。每间隔一段时间触发一次。 原理：对处理函数进行延时操作，若设定的延时到来之前，再次触发事件，则清除上一次的延时操作定时器，重新定时。 场景： resize改变布局时，onscroll滚动加载下面的图片时。 方法一：使用时间戳。当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为0)，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。 缺陷：第一次事件会立即执行，停止触发后没办法再激活事件。12345678910111213function throttle(fn, interval) &#123; var previousTime = +new Date() return function () &#123; var that = this var args = arguments var now = +new Date() if (now - previousTime &gt;= interval) &#123; previousTime = now fn.apply(that, args) &#125; &#125;&#125; 方法二：使用定时器当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。 缺陷：第一次事件会在n秒后执行，停止触发后依然会再执行一次事件。 1234567891011121314function throttle(fn, interval) &#123; var timer return function ()&#123; var that = this var args = arguments if(!timer)&#123; timer = setTimeout(function () &#123; fn.apply(that, args) timer = null &#125;, interval) &#125; &#125;&#125; 方法三：优化鼠标移入能立刻执行，停止触发的时候还能再执行一次。12345678910111213141516171819var throttle = function(func,delay)&#123; var timer = null; var startTime = Date.now(); return function()&#123; var curTime = Date.now(); var remaining = delay-(curTime-startTime); var context = this; var args = arguments; clearTimeout(timer); if(remaining&lt;=0)&#123; func.apply(context,args); startTime = Date.now(); &#125;else&#123; timer = setTimeout(func,remaining); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数柯里化]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配。 思路1.js原生自带正则2.递归思路 当模式中的第二个字符不是“*”时： 1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。 2、如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 而当模式中的第二个字符是“*”时： 如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式： 1、模式后移2字符，相当于x被忽略； 2、字符串后移1字符，模式后移2字符； 3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为可以匹配多位； 代码1234567891011121314151617181920212223242526272829303132333435363738//方法1function match(s, pattern) &#123; const reg = new RegExp(`^$&#123;pattern&#125;$`); return reg.test(s);&#125;//方法2// 第二种function matchCore(s, istr, pattern, ipattern) &#123; if (istr === s.length &amp;&amp; ipattern === pattern.length) &#123; return true; &#125; if (istr !== s.length &amp;&amp; ipattern === pattern.length) &#123; return false; &#125; if (pattern[ipattern + 1] === '*') &#123; if (pattern[ipattern] === '.' &amp;&amp; istr !== s.length || pattern[ipattern] === s[istr]) &#123; return ( matchCore(s, istr + 1, pattern, ipattern + 2) || matchCore(s, istr + 1, pattern, ipattern) || matchCore(s, istr, pattern, ipattern + 2) ); &#125; return matchCore(s, istr, pattern, ipattern + 2); &#125; if (s[istr] === pattern[ipattern] || pattern[ipattern] === '.' &amp;&amp; istr !== s.length) &#123; return matchCore(s, istr + 1, pattern, ipattern + 1); &#125; return false;&#125;function match2(s, pattern) &#123; if (s === null || pattern === null) &#123; return false; &#125; return matchCore(s, 0, pattern, 0);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建乘积数组]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 思路借助中间变量存储后面的乘积 代码12345678910111213141516function multiply(array) &#123; const B = [], len = array.length; B[0] = 1; // 计算前i - 1个元素的乘积 for (let i = 1; i &lt; len; i++) &#123; B[i] = array[i - 1] * B[i - 1]; &#125; let tmp = 1; // 计算后N - i个元素的乘积并连接 for (let i = len - 2; i &gt;= 0; i--) &#123; tmp *= array[i + 1]; B[i] *= tmp; &#125; return B;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把字符串转化为整数]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 思路不能使用parseInt函数，要求自己实现，可以使用位运算 代码1234567891011121314function StrToInt(str) &#123; let res = 0, flag = 1; const n = str.length; if (!n) return 0; if (str[0] === '-') &#123; flag = -1; &#125; for (let i = str[0] === '+' || str[0] === '-' ? 1 : 0; i &lt; n; i++) &#123; if (!(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')) return 0; res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + (str[i] - '0'); &#125; return res * flag;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重复的数]]></title>
    <url>%2F2019%2F05%2F11%2F%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路利用map ，键值对应求解 代码1234567891011121314function duplicate(numbers, duplication) &#123; const map = &#123;&#125;; let flag = false; for (let i = 0; i &lt; numbers.length; i++) &#123; if (!map[numbers[i]]) &#123; map[numbers[i]] = 1; &#125; else &#123; duplication[0] = numbers[i]; flag = true; break; &#125; &#125; return flag;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F05%2F11%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 思路二进制、位运算 代码12345678function Add(num1, num2) &#123; while (num2 !== 0) &#123; const tmp1 = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = tmp1; &#125; return num1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算题]]></title>
    <url>%2F2019%2F05%2F11%2F%E8%AE%A1%E7%AE%97%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 思路位运算+递归 代码123function SumSolution(n) &#123; return n &amp;&amp; Sum_Solution(n - 1) + n;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[孩子们的游戏]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 思路约瑟夫环问题 代码1234567891011121314function LastRemainingSolution(n, m) &#123; if (n === 0 || m === 0) return -1; const child = []; let del = 0; for (let i = 0; i &lt; n; i++) &#123; child[i] = i; &#125; while (child.length &gt; 1) &#123; const k = m - 1; del = (del + k) % child.length; child.splice(del, 1); &#125; return child[0];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扑克牌游戏]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%89%91%E5%85%8B%E7%89%8C%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。 思路要求是顺子，则要求5个数最大最小数的差不超过5，且不能有重复的数字 代码12345678910111213141516function IsContinuous(numbers) &#123; let max = 0, min = 14, flag = 0; if (numbers.length !== 5) return false; for (let i = 0; i &lt; numbers.length; i++) &#123; if (numbers[i] &gt; 13 || numbers[i] &lt; 0) return false; if (numbers[i] === 0) continue; if ((flag &gt;&gt; numbers[i] &amp; 1) === 1) return false; flag = flag | 1 &lt;&lt; numbers[i]; if (numbers[i] &gt; max) max = numbers[i]; if (numbers[i] &lt; min) min = numbers[i]; &#125; if (max - min &gt;= 5) return false; return true;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转单词序列]]></title>
    <url>%2F2019%2F05%2F08%2F%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am astudent.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路js直接调api 代码123456function ReverseSentence(str) &#123; return str .split(' ') .reverse() .join(' ');&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串左旋]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A6%E6%97%8B%2F</url>
    <content type="text"><![CDATA[题目汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路js的话直接调用splice函数就行了 代码12345function LeftRotateString(str, n) &#123; if (str === null || str.length === 0) return ''; n = n % str.length; return str.slice(n) + str.slice(0, n);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为s的字符串]]></title>
    <url>%2F2019%2F05%2F07%2F%E9%80%92%E5%A2%9E%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BAs%2F</url>
    <content type="text"><![CDATA[题目输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 思路数学题，和相同的乘积最小，画函数，两个数的相距距离最远即可 代码1234567891011121314151617function FindNumbersWithSum(array, sum) &#123; if (array.length &lt; 2) return []; let left = 0, right = array.length - 1; const res = []; while (left &lt; right) &#123; if (array[left] + array[right] &lt; sum) &#123; left++; &#125; else if (array[left] + array[right] &gt; sum) &#123; right--; &#125; else &#123; res.push(array[left], array[right]); break; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为s的连续正数序列]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 思路数学思路：假设序列的开始数字为a,结束数字为a+i，那么有(a+i-a+1)*(a+a+i)/2=sum只需要找到a,i就可以找到序列 代码123456789101112131415161718192021222324252627282930function FindContinuousSequence(sum) &#123; let a = 0, half = sum &gt;&gt; 1; const res = []; while (half--) &#123; a++; let i = 1; while ((i + 1) * (2 * a + i) &lt; 2 * sum) &#123; i++; &#125; if ((i + 1) * (2 * a + i) === 2 * sum) &#123; const tmp = []; tmp.push(a); tmp.push(i); res.push(tmp); &#125; &#125; for (let i = 0; i &lt; res.length; i++) &#123; let num = res[i][1], k = 1; const tmp = []; tmp.push(res[i][0]); while (num--) &#123; tmp.push(res[i][0] + k); k++; &#125; res[i] = tmp; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中只出现一次的数]]></title>
    <url>%2F2019%2F05%2F06%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路使用map记录下每个数的次数，占空间。 代码123456789101112131415161718function FindNumsAppearOnce(array) &#123; const map = &#123;&#125;, res = []; for (let i = 0; i &lt; array.length; i++) &#123; if (!map[array[i]]) &#123; map[array[i]] = 1; &#125; else &#123; map[array[i]]++; &#125; &#125; for (let i = 0; i &lt; array.length; i++) &#123; if (map[array[i]] === 1) &#123; res.push(array[i]); &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路递归判断左右子树相差为多少 代码123456789101112function IsBalanced_Solution(pRoot) &#123; if (pRoot == null) return true; let leftLen = TreeDepth(pRoot.left); let rightLen = TreeDepth(pRoot.right); return Math.abs(rightLen - leftLen) &lt;= 1 &amp;&amp; IsBalanced_Solution(pRoot.left) &amp;&amp; IsBalanced_Solution(pRoot.right);&#125;function TreeDepth(pRoot) &#123; if (pRoot == null) return 0; let leftLen = TreeDepth(pRoot.left); let rightLen = TreeDepth(pRoot.right); return Math.max(leftLen, rightLen) + 1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解call、apply]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3call%E3%80%81apply%2F</url>
    <content type="text"><![CDATA[call的概念1call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 例如123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 注意两点： 1.call 改变了 this 的指向，指向到 foo 2.bar 函数执行了 模拟第一版 12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;;foo.bar(); // 1 然而添加了新的属性，所以还需删除新方法实现结果如下123456789101112131415161718// 第一版Function.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call2(foo); // 1 模拟最终版本1.函数具有返回值2.this 参数可以传 null，当为 null 的时候，视为指向 window 实现方法如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125;// 测试一下var value = 2;var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call2(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 同理实现apply12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; 参考链接]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
        <tag>上下文this相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的深度]]></title>
    <url>%2F2019%2F05%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路递归遍历二叉树的深度为左右子树深度大的那一个 代码123456function TreeDepth(pRoot) &#123; if (pRoot === null) return 0; const leftDep = TreeDepth(pRoot.left); const rightDep = TreeDepth(pRoot.right); return Math.max(leftDep, rightDep) + 1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字在排序数组中出现的次数]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目统计一个数字在排序数组中出现的次数。 思路二分查找找到数字开始的位置和数字结束的位置，然后相减 代码12345678910111213141516171819202122232425262728293031323334function GetNumberOfK(data, k) &#123; if (getEnd(data, k) === -1 &amp;&amp; getBegin(data, k) === -1) return 0; return getEnd(data, k) - getBegin(data, k) + 1;&#125;function getBegin(data, k) &#123; let [left, right] = [0, data.length - 1]; let mid = left + right &gt;&gt; 1; while (left &lt;= right) &#123; if (data[mid] &gt; k) &#123; right = mid - 1; &#125; else if (data[mid] &lt; k) &#123; left = mid + 1; &#125; else if (mid - 1 &gt;= 0 &amp;&amp; data[mid - 1] === k) &#123; right = mid - 1; &#125; else return mid; mid = left + right &gt;&gt; 1; &#125; return -1;&#125;function getEnd(data, k) &#123; let [left, right] = [0, data.length - 1]; let mid = left + right &gt;&gt; 1; while (left &lt;= right) &#123; if (data[mid] &gt; k) &#123; right = mid - 1; &#125; else if (data[mid] &lt; k) &#123; left = mid + 1; &#125; else if (mid + 1 &lt; data.length &amp;&amp; data[mid + 1] === k) &#123; left = mid + 1; &#125; else return mid; mid = left + right &gt;&gt; 1; &#125; return -1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两链表的公共节点]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%B8%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目输入两个链表，找出它们的第一个公共结点。 思路快慢指针 代码1234567891011121314151617181920212223242526272829303132function FindFirstCommonNode(pHead1, pHead2) &#123; const len1 = getLinkLength(pHead1), len2 = getLinkLength(pHead2); let pLong = pHead1, pShort = pHead2, lenGap = len1 - len2; if (len1 &lt; len2) &#123; pLong = pHead2; pShort = pHead1; lenGap = len2 - len1; &#125; while (lenGap--) &#123; pLong = pLong.next; &#125; while (pLong !== null) &#123; // pLong,pShort一起跑 if (pLong.val === pShort.val) &#123; return pLong; &#125; pLong = pLong.next; pShort = pShort.next; &#125; return null;&#125;function getLinkLength(pHead) &#123; let length = 0; while (pHead !== null) &#123; pHead = pHead.next; length++; &#125; return length;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中的逆序对]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 思路归并排序的思路 先把数组分隔成子数组， 先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。 代码1234567891011121314151617181920212223242526272829function InversePairs(data) &#123; if (!data || data.length &lt; 2) return 0; const copy = data.slice(); let count = 0; count = mergeCount(data, copy, 0, data.length - 1); return count % 1000000007;&#125;function mergeCount(data, copy, start, end) &#123; if (start === end) return 0; const mid = end - start &gt;&gt; 1, left = mergeCount(copy, data, start, start + mid), // 注意参数，copy作为data传入 right = mergeCount(copy, data, start + mid + 1, end); // 注意参数，copy作为data传入 let [p, q, count, copyIndex] = [start + mid, end, 0, end]; while (p &gt;= start &amp;&amp; q &gt;= start + mid + 1) &#123; if (data[p] &gt; data[q]) &#123; copy[copyIndex--] = data[p--]; count = count + q - start - mid; &#125; else &#123; copy[copyIndex--] = data[q--]; &#125; &#125; while (p &gt;= start) &#123; copy[copyIndex--] = data[p--]; &#125; while (q &gt;= start + mid + 1) &#123; copy[copyIndex--] = data[q--]; &#125; return count + left + right;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个只出现一次的字符]]></title>
    <url>%2F2019%2F05%2F01%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置 思路使用map来记录字符出现的次数即可 代码1234567891011121314151617function FirstNotRepeatingChar(str) &#123; if (str.length &lt; 1 || str.length &gt; 10000) return -1; const map = &#123;&#125;; for (let i = 0; i &lt; str.length; i++) &#123; if (!map[str[i]]) &#123; map[str[i]] = 1;//未出现过则map次数为1 &#125; else &#123; map[str[i]]++;//出现过则次数在加一 &#125; &#125; for (let i = 0; i &lt; str.length; i++) &#123; if (map[str[i]] === 1) &#123; return i;//找到出现次数第一个为一的字符 &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丑数]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路动态规划 把前面的丑数存着，生成后面的丑数。t2,t3,t5是判断点，用于判断从何处开始选出并乘以对应因子肯定会大于当前数组中最大丑数，而前面的丑数不用考虑。 代码123456789101112function GetUglyNumber_Solution(index) &#123; if (index === 0) return 0; var uglyNum = [1]; var factor2 = 0, factor3 = 0, factor5 = 0; for (var i = 1; i &lt; index; i++) &#123; uglyNum[i] = Math.min(uglyNum[factor2] * 2, uglyNum[factor3] * 3, uglyNum[factor5] * 5); if (uglyNum[i] === uglyNum[factor2] * 2) factor2++; if (uglyNum[i] === uglyNum[factor3] * 3) factor3++; if (uglyNum[i] === uglyNum[factor5] * 5) factor5++; &#125; return uglyNum[index - 1];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾经的博客地址]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%9B%BE%E7%BB%8F%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[博客地址]]></content>
      <categories>
        <category>以前的博客</category>
      </categories>
  </entry>
</search>
