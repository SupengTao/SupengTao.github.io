<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo是如何运作的]]></title>
    <url>%2F2019%2F08%2F07%2Fhexo%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84%2F</url>
    <content type="text"><![CDATA[说来惭愧，用hexo几个月了，却对hexo本身没什么了解，今天看了下vue-cli的原理，感觉和hexo有相似之处，才打算深入了解一下hexo的构建原理。 hexo的文件结构]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树查找最近公共父节点]]></title>
    <url>%2F2019%2F07%2F29%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%88%B6%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目查询二叉树中两个节点的最近公共父节点 思路递归查找，具体看注释 代码123456789101112131415161718// function Node(x)&#123;// this.val=x;// this.left=null;// this.right=null;// &#125;//定义节点结构function parent(root,a,b)&#123; if(root==null) return null;//如果根节点为空则返回空 if(root==a||root==b) return root;//如果a，b之中有一个是根节点，则返回根节点 var left=parent(root.left,a,b); var right=parent(root.right,a,b);//递归左右子树的结果 if(left&amp;&amp;right)&#123; return root;//如果a,b分别在左右子树上，则最近的公共节点是root &#125; return left?left:right;//不为空的那个是公共父节点&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个promise方法]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[看到好多次面试题有要求实现一个promise了，打算实现以下，理清思路，一步一步实现，其实也不难。 定义promise内部三个状态123const PENDING = 'pending';//进行中const FULFILLED = 'fulfilled';//成功或者“resolved”const REJECTED = 'rejected';//失败 定义promise主函数1234567891011121314151617181920212223242526272829303132333435363738394041424344function Promise(executor)&#123; let self = this; //先缓存当前promise实例 self.status = PENDING;//设置状态 //定义存放成功的回调的数组 self.onResolvedCallbacks = []; //定义存放失败回调的数组 self.onRejectedCallbacks = []; //当调用此方法的时候，如果promise状态为pending,的话可以转成成功态,如果已经是成功态或者失败态了，则什么都不做 //2.1 定义resolve方法; function resolve(value)&#123; if(value!=null &amp;&amp;value.then&amp;&amp;typeof value.then == 'function')&#123; return value.then(resolve,reject); &#125; //如果是初始态，则转成成功态 //为什么要把它用setTimeout包起来 setTimeout(function()&#123; if(self.status == PENDING)&#123; self.status = FULFILLED; self.value = value;//成功后会得到一个值，这个值不能改 //调用所有成功的回调 self.onResolvedCallbacks.forEach(cb=&gt;cb(self.value)); &#125; &#125;) &#125; //2.1.2 定义reject方法; function reject(reason)&#123; setTimeout(function()&#123; //如果是初始态，则转成失败态 if(self.status == PENDING)&#123; self.status = REJECTED; self.value = reason;//失败的原因给了value self.onRejectedCallbacks.forEach(cb=&gt;cb(self.value)); &#125; &#125;); &#125; try&#123; //因为此函数执行可能会异常，所以需要捕获，如果出错了，需要用错误 对象reject executor(resolve,reject); &#125;catch(e)&#123; //如果这函数执行失败了，则用失败的原因reject这个promise reject(e); &#125;;&#125; 实现promise相关APIthen()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//onFulfilled 是用来接收promise成功的值或者失败的原因Promise.prototype.then = function(onFulfilled,onRejected)&#123; //如果成功和失败的回调没有传，则表示这个then没有任何逻辑，只会把值往后抛 //2.2.1 onFulfilled = typeof onFulfilled == 'function'?onFulfilled:function(value)&#123;return value&#125;; onRejected = typeof onRejected == 'function'?onRejected:reason=&gt;&#123;throw reason&#125;; //如果当前promise状态已经是成功态了，onFulfilled直接取值 let self = this; let promise2; if(self.status == FULFILLED)&#123; return promise2 = new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; try&#123; let x =onFulfilled(self.value); //如果获取到了返回值x,会走解析promise的过程 resolvePromise(promise2,x,resolve,reject); &#125;catch(e)&#123; //如果执行成功的回调过程中出错了，用错误原因把promise2 reject reject(e); &#125; &#125;) &#125;); &#125; if(self.status == REJECTED)&#123; return promise2 = new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; try&#123; let x =onRejected(self.value); resolvePromise(promise2,x,resolve,reject); &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125;); &#125; if(self.status == PENDING)&#123; return promise2 = new Promise(function(resolve,reject)&#123; self.onResolvedCallbacks.push(function()&#123; try&#123; let x =onFulfilled(self.value); //如果获取到了返回值x,会走解析promise的过程 resolvePromise(promise2,x,resolve,reject); &#125;catch(e)&#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push(function()&#123; try&#123; let x =onRejected(self.value); resolvePromise(promise2,x,resolve,reject); &#125;catch(e)&#123; reject(e); &#125; &#125;); &#125;); &#125;&#125; resolve()12345Promise.resolve = function(value)&#123; return new Promise(function(resolve)&#123; resolve(value); &#125;);&#125; reject()123456//返回一个立刻失败的promisePromise.reject = function(reason)&#123; return new Promise(function(resolve,reject)&#123; reject(reason); &#125;);&#125; all()1234567891011121314151617181920Promise.all = function(promises)&#123; return new Promise(function(resolve,reject)&#123; let done = gen(promises.length,resolve); for(let i=0;i&lt;promises.length;i++)&#123; promises[i].then(function(data)&#123; done(i,data); &#125;,reject); &#125; &#125;);&#125;function gen(times,cb)&#123; let result = [],count=0; return function(i,data)&#123; result[i] = data; if(++count==times)&#123; cb(result); &#125; &#125;&#125; catch()1234//catch原理就是只传失败的回调Promise.prototype.catch = function(onRejected)&#123; this.then(null,onRejected);&#125; 参考资料[1] https://juejin.im/entry/597ddade5188257f98295191 [2] https://juejin.im/post/5c763869e51d4569013c11f5#heading-5]]></content>
      <categories>
        <category>promise</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的设计模式]]></title>
    <url>%2F2019%2F07%2F15%2FJS%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义1设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案 简单来说，设计模式是解决某个特定场景下对某种问题的解决方案。 以下是几种常见的JS设计模式 单例模式单例模式提供了一种将代码组织为一个逻辑单元的手段，这个逻辑单元中的代码可以通过单一变量进行访问。 单体模式的优点是：1.可以用来划分命名空间，减少全局变量的数量。2.使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。3.可以被实例化，且实例化一次。 适用场景：例如弹窗，无论点击多少次，弹窗只应该被创建一次。 单例的例子123456789101112131415161718192021222324class CreateUser &#123; constructor(name) &#123; this.name = name; this.getName(); &#125; getName() &#123; return this.name; &#125;&#125;// 代理实现单例模式var ProxyMode = (function() &#123; var instance = null; return function(name) &#123; if(!instance) &#123; instance = new CreateUser(name); &#125;//如果已经实例化则返回实例，反之则实例化一个实例 return instance; &#125;&#125;)();// 测试单体模式的实例var a = new ProxyMode("aaa");var b = new ProxyMode("bbb");// 因为单体模式是只实例化一次，所以下面的实例是相等的console.log(a === b); //true 装饰者模式1装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移hexo博客遇到的一些问题]]></title>
    <url>%2F2019%2F07%2F12%2F%E8%BF%81%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[起因终于结束了漫长的考试周，准备开始继续更新博客了。结果实习后换了分配的电脑，发现在迁移博客的过程中遇到了一些问题，就记录下来，以便后续再迁移的时候避坑。 博客源码问题本来打算直接从github上clone一份下来直接更新，结果发现github上存的代码只包含了网页源码，后台操作的代码没有上传。通过搜索后，解决方法如下： 在现有的XXX.github.io项目上创建一个分支来管理 克隆gitHub上的XXX.github.io项目的文件到本地 1git clone https://github.com/yourname/xxx.github.io.git 删除文件夹里除了.git的其他所有文件 把hexo项目文件下的所有文件全部复制过来 里面应该有一个叫.gitignore的文件，如果没有就输入 touch .gitignore，创建一个 .gitignore文件里应该是这些内容 1234567.DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 创建一个叫hexo的分支并切换到这个分支上 1git checkout -b hexo 提交复制过来的文件到暂存区 1git add --all 提交 1git commit -m &quot;新建分支资源文件&quot; 推送分支到github 1git push --set-upstream origin hexo 到这一步我们就基本上搞定了，以后再跟新了博客就直接 git push就可以了，hexo的操作跟以前一样不变。 今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。 克隆分支的操作 1git clone -b hexo https://github.com/yourname/xxx.github.io.git 因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。 这样做完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。 github上不显示contribution记录的问题在几次更细博客后，发现在github的contribution图上没有显示对应的活动记录后来发现是因为在本机的git账号使用的公司分配的git账号，切换成github个人账号后即可解决问题]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于fetch的使用]]></title>
    <url>%2F2019%2F06%2F11%2F%E5%85%B3%E4%BA%8Efetch%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[起源在 Ajax 中涉及到的 JavaScript 方面的技术，即 XMLHttpRequest（以下简称 XHR）。很长一段时间我们都是通过 XHR 来与服务器建立异步通信。然而在使用的过程中，我们发现 XHR 是基于事件的异步模型，在设计上将输入、输出和事件监听混杂在一个对象里，且必须通过实例化方式来发请求。配置和调用方式混乱，不符合关注分点离原则。 基于此需求提出了Fetch API fetch的使用 该fetch()方法返回一个Promise解析Response来自Request显示状态（成功与否）的方法。如果您promise {}在控制台日志屏幕中收到此消息，请不要惊慌 - 它基本上意味着Promise工作，但等待解决。因此，为了解决它，我们需要 .then()处理程序（回调）来访问内容。 所以简而言之，我们首先定义路径（Fetch），其次是从服务器请求数据（Request），第三个定义内容类型（Body），最后但并非最不重要的是，我们访问数据（Response）。 以下为使用fetch的一个例子 123456789101112131415161718fetch('./api/some.json') .then( function(response) &#123; if (response.status !== 200) &#123; console.log('Looks like there was a problem. Status Code: ' + response.status); return; &#125; // Examine the text in the response response.json().then(function(data) &#123; console.log(data); &#125;); &#125; ) .catch(function(err) &#123; console.log('Fetch Error :-S', err); &#125;); fetch相比于ajax的优势fetch基于promise实现，所以fetch在应用了async写法后，可以将异步操作写的和同步操作一样清晰易懂。]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>fetch</tag>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的非递归遍历]]></title>
    <url>%2F2019%2F06%2F04%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[思路非递归遍历需要用到辅助的栈来存储需要遍历的节点。 前序遍历123456789101112131415161718function first(root) &#123; var arr=[],res=[]; if(root!=null)&#123; arr.push(root); &#125; while(arr.length!=0)&#123; var temp=arr.pop(); res.push(temp.val); //这里先放右边再放左边是因为取出来的顺序相反 if(temp.right!=null)&#123; arr.push(temp.right); &#125; if(temp.left!=null)&#123; arr.push(temp.left); &#125; &#125; return res;&#125; 中序遍历12345678910111213141516171819function LDR(root)&#123;var arr=[],res=[];while(true)&#123; while(root!=null)&#123; arr.push(root); root=root.left; &#125; //终止条件：最后树遍历完了自然就结束 if(arr.length==0)&#123; break; &#125; var temp=arr.pop(); res.push(temp.val); root=temp.right;&#125;return res;&#125;LDR(root)//4,2,5,1,6,3,7 后续遍历1234567891011121314151617function LRD(root)&#123;var arr=[],res=[];arr.push(root);while(arr.length!=0)&#123; var p=arr.pop(); res.push(p.val); if(p.left!=null)&#123; arr.push(p.left); &#125; if(p.right!=null)&#123; arr.push(p.right); &#125;&#125;return res.reverse();&#125;LRD(root)//4,5,2,6,7,3,1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组同构分组]]></title>
    <url>%2F2019%2F05%2F31%2F%E6%95%B0%E7%BB%84%E5%90%8C%E6%9E%84%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目Given an array of strings, group anagrams together. For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”], ouput：[ [“ate”, “eat”,”tea”], [“nat”,”tan”], [“bat”]] 思路运用hashmap来解决 代码12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int n=strs.size(); if(n==0) return vector&lt;vector&lt;string&gt;&gt; (); vector&lt;vector&lt;string&gt;&gt; res; unordered_map&lt;string, vector&lt;string&gt;&gt; hash; //(1)将字符串数组先按字典顺序排序 sort(strs.begin(), strs.end()); //(2)构造hash表 for(int i=0;i&lt;n;i++) &#123;//将排序后相等的字符串放在相同的vector string tmp=strs[i]; sort(tmp.begin(), tmp.end()); hash[tmp].push_back(strs[i]); &#125; unordered_map&lt;string, vector&lt;string&gt;&gt;::iterator it; for(it=hash.begin();it != hash.end();it++) &#123;//(3)将hash表中的value值(数组形式)放到结果数组 res.push_back(it-&gt;second); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵中的路径]]></title>
    <url>%2F2019%2F05%2F29%2F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 思路采用回溯法，当发现一个节点不符合时，回退上一个节点寻找匹配的节点 代码123456789101112131415161718192021222324252627282930313233343536373839function hasPath(matrix, rows, cols, path) &#123; const pathLength = 0; const visited = new Array(rows * cols); for (let row = 0; row &lt; rows; row++) &#123; for (let col = 0; col &lt; cols; col++) &#123; // 遍历，遍历的点为起点。 if (hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited)) &#123; return true; &#125; &#125; &#125; return false;&#125;function hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited) &#123; let hasPath = false; if (pathLength === path.length) return true; if ( row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; matrix[row * cols + col] === path[pathLength] &amp;&amp; !visited[row * cols + col] ) &#123; ++pathLength; visited[row * cols + col] = true; // 因为||为短路运算符，只要第一个满足就会返回，而不会去计算后面的，所以有些路径可以不用去走。 hasPath = hasPathCore(matrix, rows, cols, row - 1, col, path, pathLength, visited) || hasPathCore(matrix, rows, cols, row, col - 1, path, pathLength, visited) || hasPathCore(matrix, rows, cols, row + 1, col, path, pathLength, visited) || hasPathCore(matrix, rows, cols, row, col + 1, path, pathLength, visited); if (!hasPath) &#123; --pathLength; visited[row * cols + col] = false; &#125; &#125; return hasPath;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口的最大值]]></title>
    <url>%2F2019%2F05%2F28%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}，{2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路用队列来模拟窗口同时，利用两个栈来模拟队列可以降低复杂度 代码12345678910111213141516171819202122232425function maxInWindows(num, size)&#123; let res = []; if(size == 0)&#123; return res; &#125; let begin; let queue = []; for(let i = 0; i &lt; num.length; i++)&#123; begin = i - size + 1;//代表滑动窗口的左边界 if(queue.length == 0)&#123; queue.push(i); &#125;else if(begin &gt; queue[0])&#123; queue.shift(); &#125; while((queue.length != 0) &amp;&amp; (num[queue[queue.length - 1]] &lt;= num[i]))&#123; queue.pop(); &#125; queue.push(i); if(begin &gt;= 0)&#123; res.push(num[queue[0]]) &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据流中的中位数]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 思路思路没什么好说的，主要拓展在不同情况下的不同数据结构，进行操作时的不同复杂度，寻找最优解 代码12345678910111213const array = [];function Insert(num) &#123; array.push(num); for (let i = array.length - 2; array[i] &gt; num; i--) &#123; [array[i], array[i + 1]] = [array[i + 1], array[i]]; &#125;&#125;function GetMedian() &#123; if (array.length &amp; 1 === 1) &#123; return array[(array.length - 1) / 2]; &#125; return (array[array.length / 2] + array[array.length / 2 - 1]) / 2;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的第k个节点]]></title>
    <url>%2F2019%2F05%2F27%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 思路二叉搜索树的中序遍历即为从小到大排列 代码1234567891011121314151617181920212223function KthNode(pRoot, k) &#123; if (pRoot === null || k === 0) &#123; return null; &#125; // 为了能追踪k，应该把KthNodeCore函数定义在这里面，k应该在KthNodeCore函数外面 function KthNodeCore(pRoot) &#123; let target = null; if (pRoot.left !== null) &#123; target = KthNodeCore(pRoot.left, k); &#125; if (target === null) &#123; if (k === 1) &#123; target = pRoot; &#125; k--; &#125; if (target === null &amp;&amp; pRoot.right !== null) &#123; target = KthNodeCore(pRoot.right, k); &#125; return target; &#125; return KthNodeCore(pRoot);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化二叉树]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目请实现两个函数，分别用来序列化和反序列化二叉树 思路序列化二叉树即将二叉树转化为字符串形式（前中后序），需要注意将空节点标识出来，反序列化需要注意标识是否为空节点 代码12345678910111213141516171819202122232425const arr = [];function Serialize(pRoot) &#123; // write code here if (pRoot === null) &#123; arr.push('a'); &#125; else &#123; arr.push(pRoot.val); Serialize(pRoot.left); Serialize(pRoot.right); &#125;&#125;function Deserialize() &#123; // write code here let node = null; if (arr.length &lt; 1) &#123; return null; &#125; const number = arr.shift(); if (typeof number === 'number') &#123; node = new TreeNode(number); node.left = Deserialize(); node.right = Deserialize(); &#125; return node;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按层打印二叉树]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路记录上一层的子节点个数，才能按个数分行，引入一个辅助队列 代码12345678910111213141516171819202122232425262728293031function Print(pRoot) &#123; const queue = [], res = []; if (pRoot === null) &#123; return res; &#125; queue.push(pRoot); let nextLevel = 0; // 下一层节点个数 let toBePrinted = 1; // 这一层还有多少个节点要打印 let list = []; // 存放每一层节点 while (queue.length) &#123; const pNode = queue.shift(); list.push(pNode.val); if (pNode.left !== null) &#123; queue.push(pNode.left); nextLevel++; &#125; if (pNode.right !== null) &#123; queue.push(pNode.right); nextLevel++; &#125; toBePrinted--; if (toBePrinted === 0) &#123; res.push(list); list = []; toBePrinted = nextLevel; nextLevel = 0; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[之字形打印二叉树]]></title>
    <url>%2F2019%2F05%2F25%2F%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 思路画图分析，使用两个栈进行操作 代码12345678910111213141516171819202122232425262728293031323334353637383940function Print(pRoot) &#123; const lists = []; if (pRoot === null) &#123; return lists; &#125; const stack1 = []; const stack2 = []; stack2.push(pRoot); let i = 1; while (stack1.length !== 0 || stack2.length !== 0) &#123; const list = []; // 为奇数层 if ((i &amp; 1) === 1) &#123; while (stack2.length !== 0) &#123; const tmp = stack2[stack2.length - 1]; stack2.pop(); list.push(tmp.val); if (tmp.left !== null) stack1.push(tmp.left); if (tmp.right !== null) stack1.push(tmp.right); &#125; &#125; // 为偶数层 else &#123; while (stack1.length !== 0) &#123; const tmp = stack1[stack1.length - 1]; stack1.pop(); list.push(tmp.val); if (tmp.right !== null) stack2.push(tmp.right); if (tmp.left !== null) stack2.push(tmp.left); &#125; &#125; ++i; lists.push(list); &#125; return lists; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称的二叉树]]></title>
    <url>%2F2019%2F05%2F24%2F%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路与树相关的常用递归的思路来解决 代码123456789101112131415161718function isSymmetrical(pRoot) &#123; if (pRoot === null) &#123; return true; &#125; return compareRoot(pRoot.left, pRoot.right);&#125;function compareRoot(left, right) &#123; if (left === null) &#123; return right === null; &#125; if (right === null) &#123; return false; &#125; if (left.val !== right.val) &#123; return false; &#125; return compareRoot(left.left, right.right) &amp;&amp; compareRoot(left.right, right.left);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一个节点]]></title>
    <url>%2F2019%2F05%2F22%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路绘图分析，状态考虑全面即可 代码123456789101112131415161718192021function GetNext(pNode) &#123; if (pNode === null) &#123; return null; &#125; if (pNode.right !== null) &#123; // 第1种 pNode = pNode.right; while (pNode.left !== null) &#123; pNode = pNode.left; &#125; return pNode; &#125; while (pNode.next !== null) &#123; // 第2种 if (pNode === pNode.next.left) &#123; return pNode.next; &#125; pNode = pNode.next; &#125; return null;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除链表中重复的节点]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 思路注意两点：1.第一第二个节点重复需要额外创建新的头结点2.多个重复节点需要循环处理 代码12345678910111213141516171819202122232425262728293031323334353637383940function deleteDuplication(pHead)&#123; if(!pHead)&#123; return null; &#125; var tempHead = new ListNode(-1); tempHead.next = pHead; var preNode = tempHead; var curr1 = preNode.next; var curr2 = curr1.next; while(curr1)&#123; if(!curr2 || curr2.val !== curr1.val)&#123; if(curr1.next !== curr2)&#123; clear(curr1, curr2); preNode.next = curr2; &#125; else &#123; preNode = curr1; &#125; curr1 = curr2; if(curr2)&#123; curr2 = curr2.next; &#125; &#125; else &#123; if(curr2)&#123; curr2 = curr2.next; &#125; &#125; &#125; return tempHead.next; function clear(node, stop)&#123; var temp; while(node !== stop)&#123; temp = node.next; node.next = null; node = temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表中环的入口节点]]></title>
    <url>%2F2019%2F05%2F21%2F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路快慢指针 代码123456789101112131415161718function EntryNodeOfLoop(pHead) &#123; let fast = pHead; let slow = pHead; while (fast !== null &amp;&amp; fast.next !== null) &#123; slow = slow.next; fast = fast.next.next; if (fast === slow) &#123; // 两者相遇 let p = pHead; while (p !== slow) &#123; p = p.next; slow = slow.next; &#125; return p; &#125; &#125; return null;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流中第一个不重复的字符]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 思路用map来解决 代码12345678910111213141516171819let map = &#123;&#125;;function Init() &#123; map = &#123;&#125;;&#125;function Insert(ch) &#123; if (map[ch]) &#123; map[ch] += 1; &#125; else &#123; map[ch] = 1; &#125;&#125;function FirstAppearingOnce() &#123; for (const i in map) &#123; if (map[i] === 1) &#123; return i; &#125; &#125; return '#';&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表示数值的字符串]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 思路正则表达式 代码123function isNumeric(s) &#123; return s.match(/[+-]?\d*(\.\d*)?([eE][+-]?\d+)?/g)[0] === s;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数的防抖和节流]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖定义： 合并事件且不会去触发事件，当一定时间内没有触发这个事件时，才真正去触发事件。 原理：对处理函数进行延时操作，若设定的延时到来之前，再次触发事件，则清除上一次的延时操作定时器，重新定时。 场景： keydown事件上验证用户名，输入法的联想。 12345678910111213function debounce(fn, delay) &#123; var timer return function () &#123; var that = this var args = arguments clearTimeout(timer) timer = setTimeout(function () &#123; fn.apply(that, args) &#125;, delay) &#125;&#125; 节流定义： 持续触发事件时，合并一定时间内的事件，在间隔一定时间之后再真正触发事件。每间隔一段时间触发一次。 原理：对处理函数进行延时操作，若设定的延时到来之前，再次触发事件，则清除上一次的延时操作定时器，重新定时。 场景： resize改变布局时，onscroll滚动加载下面的图片时。 方法一：使用时间戳。当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为0)，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。 缺陷：第一次事件会立即执行，停止触发后没办法再激活事件。 12345678910111213function throttle(fn, interval) &#123; var previousTime = +new Date() return function () &#123; var that = this var args = arguments var now = +new Date() if (now - previousTime &gt;= interval) &#123; previousTime = now fn.apply(that, args) &#125; &#125;&#125; 方法二：使用定时器当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。 缺陷：第一次事件会在n秒后执行，停止触发后依然会再执行一次事件。 1234567891011121314function throttle(fn, interval) &#123; var timer return function ()&#123; var that = this var args = arguments if(!timer)&#123; timer = setTimeout(function () &#123; fn.apply(that, args) timer = null &#125;, interval) &#125; &#125;&#125; 方法三：优化鼠标移入能立刻执行，停止触发的时候还能再执行一次。 12345678910111213141516171819var throttle = function(func,delay)&#123; var timer = null; var startTime = Date.now(); return function()&#123; var curTime = Date.now(); var remaining = delay-(curTime-startTime); var context = this; var args = arguments; clearTimeout(timer); if(remaining&lt;=0)&#123; func.apply(context,args); startTime = Date.now(); &#125;else&#123; timer = setTimeout(func,remaining); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数柯里化]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[函数柯里化的含义柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术 书上的例子12345678910111213var currying = function (fn) &#123; var args = Array.prototype.slice.call(arguments , 1); // 获取固定参数时的除fn 以外的所有参数（我们可以认为是默认参数，参数的类型可以是函数，对象，数字，字符 Json等等） return function () &#123; // 返回的函数再进行调用的时候，获取全部参数（变化参数） // 将default默认的参数和变化参数合并 var fArgs = args.concat( Array.prototype.slice.call( arguments ) ); // 执行被柯里化的函数，并将合并好的参数丢给该函数 fn.apply( null , fArgs ); &#125;&#125;` 实现一个例子12345678910111213141516function sum()&#123; var args1 = Array.prototype.slice.call(arguments); function fn()&#123; var args2 = Array.prototype.slice.call(arguments); return sum.apply(null,args.concat(args1)); &#125; fn.valueOf = function()&#123; return args1.reduce(function()&#123; return a+b; &#125;) &#125; return fn;&#125;console.log(sum(1,2,3).valueOf());//6console.log(sum(2,3)(2).valueOf());//7]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
        <tag>函数柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题目请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配。 思路1.js原生自带正则2.递归思路 当模式中的第二个字符不是“*”时： 1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。 2、如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 而当模式中的第二个字符是“*”时： 如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式： 1、模式后移2字符，相当于x被忽略； 2、字符串后移1字符，模式后移2字符； 3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为可以匹配多位； 代码1234567891011121314151617181920212223242526272829303132333435363738//方法1function match(s, pattern) &#123; const reg = new RegExp(`^$&#123;pattern&#125;$`); return reg.test(s);&#125;//方法2// 第二种function matchCore(s, istr, pattern, ipattern) &#123; if (istr === s.length &amp;&amp; ipattern === pattern.length) &#123; return true; &#125; if (istr !== s.length &amp;&amp; ipattern === pattern.length) &#123; return false; &#125; if (pattern[ipattern + 1] === '*') &#123; if (pattern[ipattern] === '.' &amp;&amp; istr !== s.length || pattern[ipattern] === s[istr]) &#123; return ( matchCore(s, istr + 1, pattern, ipattern + 2) || matchCore(s, istr + 1, pattern, ipattern) || matchCore(s, istr, pattern, ipattern + 2) ); &#125; return matchCore(s, istr, pattern, ipattern + 2); &#125; if (s[istr] === pattern[ipattern] || pattern[ipattern] === '.' &amp;&amp; istr !== s.length) &#123; return matchCore(s, istr + 1, pattern, ipattern + 1); &#125; return false;&#125;function match2(s, pattern) &#123; if (s === null || pattern === null) &#123; return false; &#125; return matchCore(s, 0, pattern, 0);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建乘积数组]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]*A[i+1]…*A[n-1]。不能使用除法。 思路借助中间变量存储后面的乘积 代码12345678910111213141516function multiply(array) &#123; const B = [], len = array.length; B[0] = 1; // 计算前i - 1个元素的乘积 for (let i = 1; i &lt; len; i++) &#123; B[i] = array[i - 1] * B[i - 1]; &#125; let tmp = 1; // 计算后N - i个元素的乘积并连接 for (let i = len - 2; i &gt;= 0; i--) &#123; tmp *= array[i + 1]; B[i] *= tmp; &#125; return B;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把字符串转化为整数]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 思路不能使用parseInt函数，要求自己实现，可以使用位运算 代码1234567891011121314function StrToInt(str) &#123; let res = 0, flag = 1; const n = str.length; if (!n) return 0; if (str[0] === '-') &#123; flag = -1; &#125; for (let i = str[0] === '+' || str[0] === '-' ? 1 : 0; i &lt; n; i++) &#123; if (!(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')) return 0; res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + (str[i] - '0'); &#125; return res * flag;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重复的数]]></title>
    <url>%2F2019%2F05%2F11%2F%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路利用map ，键值对应求解 代码1234567891011121314function duplicate(numbers, duplication) &#123; const map = &#123;&#125;; let flag = false; for (let i = 0; i &lt; numbers.length; i++) &#123; if (!map[numbers[i]]) &#123; map[numbers[i]] = 1; &#125; else &#123; duplication[0] = numbers[i]; flag = true; break; &#125; &#125; return flag;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F05%2F11%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 思路二进制、位运算 代码12345678function Add(num1, num2) &#123; while (num2 !== 0) &#123; const tmp1 = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = tmp1; &#125; return num1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算题]]></title>
    <url>%2F2019%2F05%2F11%2F%E8%AE%A1%E7%AE%97%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 思路位运算+递归 代码123function SumSolution(n) &#123; return n &amp;&amp; Sum_Solution(n - 1) + n;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[孩子们的游戏]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 思路约瑟夫环问题 代码1234567891011121314function LastRemainingSolution(n, m) &#123; if (n === 0 || m === 0) return -1; const child = []; let del = 0; for (let i = 0; i &lt; n; i++) &#123; child[i] = i; &#125; while (child.length &gt; 1) &#123; const k = m - 1; del = (del + k) % child.length; child.splice(del, 1); &#125; return child[0];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扑克牌游戏]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%89%91%E5%85%8B%E7%89%8C%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。 思路要求是顺子，则要求5个数最大最小数的差不超过5，且不能有重复的数字 代码12345678910111213141516function IsContinuous(numbers) &#123; let max = 0, min = 14, flag = 0; if (numbers.length !== 5) return false; for (let i = 0; i &lt; numbers.length; i++) &#123; if (numbers[i] &gt; 13 || numbers[i] &lt; 0) return false; if (numbers[i] === 0) continue; if ((flag &gt;&gt; numbers[i] &amp; 1) === 1) return false; flag = flag | 1 &lt;&lt; numbers[i]; if (numbers[i] &gt; max) max = numbers[i]; if (numbers[i] &lt; min) min = numbers[i]; &#125; if (max - min &gt;= 5) return false; return true;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转单词序列]]></title>
    <url>%2F2019%2F05%2F08%2F%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am astudent.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路js直接调api 代码123456function ReverseSentence(str) &#123; return str .split(' ') .reverse() .join(' ');&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串左旋]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A6%E6%97%8B%2F</url>
    <content type="text"><![CDATA[题目汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路js的话直接调用splice函数就行了 代码12345function LeftRotateString(str, n) &#123; if (str === null || str.length === 0) return ''; n = n % str.length; return str.slice(n) + str.slice(0, n);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为s的字符串]]></title>
    <url>%2F2019%2F05%2F07%2F%E9%80%92%E5%A2%9E%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BAs%2F</url>
    <content type="text"><![CDATA[题目输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 思路数学题，和相同的乘积最小，画函数，两个数的相距距离最远即可 代码1234567891011121314151617function FindNumbersWithSum(array, sum) &#123; if (array.length &lt; 2) return []; let left = 0, right = array.length - 1; const res = []; while (left &lt; right) &#123; if (array[left] + array[right] &lt; sum) &#123; left++; &#125; else if (array[left] + array[right] &gt; sum) &#123; right--; &#125; else &#123; res.push(array[left], array[right]); break; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为s的连续正数序列]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 思路数学思路：假设序列的开始数字为a,结束数字为a+i，那么有(a+i-a+1)*(a+a+i)/2=sum只需要找到a,i就可以找到序列 代码123456789101112131415161718192021222324252627282930function FindContinuousSequence(sum) &#123; let a = 0, half = sum &gt;&gt; 1; const res = []; while (half--) &#123; a++; let i = 1; while ((i + 1) * (2 * a + i) &lt; 2 * sum) &#123; i++; &#125; if ((i + 1) * (2 * a + i) === 2 * sum) &#123; const tmp = []; tmp.push(a); tmp.push(i); res.push(tmp); &#125; &#125; for (let i = 0; i &lt; res.length; i++) &#123; let num = res[i][1], k = 1; const tmp = []; tmp.push(res[i][0]); while (num--) &#123; tmp.push(res[i][0] + k); k++; &#125; res[i] = tmp; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中只出现一次的数]]></title>
    <url>%2F2019%2F05%2F06%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路使用map记录下每个数的次数，占空间。 代码123456789101112131415161718function FindNumsAppearOnce(array) &#123; const map = &#123;&#125;, res = []; for (let i = 0; i &lt; array.length; i++) &#123; if (!map[array[i]]) &#123; map[array[i]] = 1; &#125; else &#123; map[array[i]]++; &#125; &#125; for (let i = 0; i &lt; array.length; i++) &#123; if (map[array[i]] === 1) &#123; res.push(array[i]); &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路递归判断左右子树相差为多少 代码123456789101112function IsBalanced_Solution(pRoot) &#123; if (pRoot == null) return true; let leftLen = TreeDepth(pRoot.left); let rightLen = TreeDepth(pRoot.right); return Math.abs(rightLen - leftLen) &lt;= 1 &amp;&amp; IsBalanced_Solution(pRoot.left) &amp;&amp; IsBalanced_Solution(pRoot.right);&#125;function TreeDepth(pRoot) &#123; if (pRoot == null) return 0; let leftLen = TreeDepth(pRoot.left); let rightLen = TreeDepth(pRoot.right); return Math.max(leftLen, rightLen) + 1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解call、apply]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3call%E3%80%81apply%2F</url>
    <content type="text"><![CDATA[call的概念1call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 例如 123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 注意两点： 1.call 改变了 this 的指向，指向到 foo 2.bar 函数执行了 模拟第一版 12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;;foo.bar(); // 1 然而添加了新的属性，所以还需删除新方法实现结果如下 123456789101112131415161718// 第一版Function.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call2(foo); // 1 模拟最终版本1.函数具有返回值2.this 参数可以传 null，当为 null 的时候，视为指向 window 实现方法如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125;// 测试一下var value = 2;var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call2(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 同理实现apply12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; 参考链接]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
        <tag>上下文this相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的深度]]></title>
    <url>%2F2019%2F05%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路递归遍历二叉树的深度为左右子树深度大的那一个 代码123456function TreeDepth(pRoot) &#123; if (pRoot === null) return 0; const leftDep = TreeDepth(pRoot.left); const rightDep = TreeDepth(pRoot.right); return Math.max(leftDep, rightDep) + 1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字在排序数组中出现的次数]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目统计一个数字在排序数组中出现的次数。 思路二分查找找到数字开始的位置和数字结束的位置，然后相减 代码12345678910111213141516171819202122232425262728293031323334function GetNumberOfK(data, k) &#123; if (getEnd(data, k) === -1 &amp;&amp; getBegin(data, k) === -1) return 0; return getEnd(data, k) - getBegin(data, k) + 1;&#125;function getBegin(data, k) &#123; let [left, right] = [0, data.length - 1]; let mid = left + right &gt;&gt; 1; while (left &lt;= right) &#123; if (data[mid] &gt; k) &#123; right = mid - 1; &#125; else if (data[mid] &lt; k) &#123; left = mid + 1; &#125; else if (mid - 1 &gt;= 0 &amp;&amp; data[mid - 1] === k) &#123; right = mid - 1; &#125; else return mid; mid = left + right &gt;&gt; 1; &#125; return -1;&#125;function getEnd(data, k) &#123; let [left, right] = [0, data.length - 1]; let mid = left + right &gt;&gt; 1; while (left &lt;= right) &#123; if (data[mid] &gt; k) &#123; right = mid - 1; &#125; else if (data[mid] &lt; k) &#123; left = mid + 1; &#125; else if (mid + 1 &lt; data.length &amp;&amp; data[mid + 1] === k) &#123; left = mid + 1; &#125; else return mid; mid = left + right &gt;&gt; 1; &#125; return -1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两链表的公共节点]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%B8%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目输入两个链表，找出它们的第一个公共结点。 思路快慢指针 代码1234567891011121314151617181920212223242526272829303132function FindFirstCommonNode(pHead1, pHead2) &#123; const len1 = getLinkLength(pHead1), len2 = getLinkLength(pHead2); let pLong = pHead1, pShort = pHead2, lenGap = len1 - len2; if (len1 &lt; len2) &#123; pLong = pHead2; pShort = pHead1; lenGap = len2 - len1; &#125; while (lenGap--) &#123; pLong = pLong.next; &#125; while (pLong !== null) &#123; // pLong,pShort一起跑 if (pLong.val === pShort.val) &#123; return pLong; &#125; pLong = pLong.next; pShort = pShort.next; &#125; return null;&#125;function getLinkLength(pHead) &#123; let length = 0; while (pHead !== null) &#123; pHead = pHead.next; length++; &#125; return length;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中的逆序对]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 思路归并排序的思路 先把数组分隔成子数组， 先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。 代码1234567891011121314151617181920212223242526272829function InversePairs(data) &#123; if (!data || data.length &lt; 2) return 0; const copy = data.slice(); let count = 0; count = mergeCount(data, copy, 0, data.length - 1); return count % 1000000007;&#125;function mergeCount(data, copy, start, end) &#123; if (start === end) return 0; const mid = end - start &gt;&gt; 1, left = mergeCount(copy, data, start, start + mid), // 注意参数，copy作为data传入 right = mergeCount(copy, data, start + mid + 1, end); // 注意参数，copy作为data传入 let [p, q, count, copyIndex] = [start + mid, end, 0, end]; while (p &gt;= start &amp;&amp; q &gt;= start + mid + 1) &#123; if (data[p] &gt; data[q]) &#123; copy[copyIndex--] = data[p--]; count = count + q - start - mid; &#125; else &#123; copy[copyIndex--] = data[q--]; &#125; &#125; while (p &gt;= start) &#123; copy[copyIndex--] = data[p--]; &#125; while (q &gt;= start + mid + 1) &#123; copy[copyIndex--] = data[q--]; &#125; return count + left + right;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个只出现一次的字符]]></title>
    <url>%2F2019%2F05%2F01%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置 思路使用map来记录字符出现的次数即可 代码1234567891011121314151617function FirstNotRepeatingChar(str) &#123; if (str.length &lt; 1 || str.length &gt; 10000) return -1; const map = &#123;&#125;; for (let i = 0; i &lt; str.length; i++) &#123; if (!map[str[i]]) &#123; map[str[i]] = 1;//未出现过则map次数为1 &#125; else &#123; map[str[i]]++;//出现过则次数在加一 &#125; &#125; for (let i = 0; i &lt; str.length; i++) &#123; if (map[str[i]] === 1) &#123; return i;//找到出现次数第一个为一的字符 &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丑数]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路动态规划 把前面的丑数存着，生成后面的丑数。t2,t3,t5是判断点，用于判断从何处开始选出并乘以对应因子肯定会大于当前数组中最大丑数，而前面的丑数不用考虑。 代码123456789101112function GetUglyNumber_Solution(index) &#123; if (index === 0) return 0; var uglyNum = [1]; var factor2 = 0, factor3 = 0, factor5 = 0; for (var i = 1; i &lt; index; i++) &#123; uglyNum[i] = Math.min(uglyNum[factor2] * 2, uglyNum[factor3] * 3, uglyNum[factor5] * 5); if (uglyNum[i] === uglyNum[factor2] * 2) factor2++; if (uglyNum[i] === uglyNum[factor3] * 3) factor3++; if (uglyNum[i] === uglyNum[factor5] * 5) factor5++; &#125; return uglyNum[index - 1];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾经的博客地址]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%9B%BE%E7%BB%8F%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[由于各种原因，放弃CSDN博客的更新，转为使用hexo，以下是曾经的csdn博客地址戳这里传送]]></content>
      <categories>
        <category>以前的博客</category>
      </categories>
  </entry>
</search>
