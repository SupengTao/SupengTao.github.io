<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串左旋]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A6%E6%97%8B%2F</url>
    <content type="text"><![CDATA[题目汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路js的话直接调用splice函数就行了 代码12345function LeftRotateString(str, n) &#123; if (str === null || str.length === 0) return ''; n = n % str.length; return str.slice(n) + str.slice(0, n);&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为s的字符串]]></title>
    <url>%2F2019%2F05%2F07%2F%E9%80%92%E5%A2%9E%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BAs%2F</url>
    <content type="text"><![CDATA[题目输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 思路数学题，和相同的乘积最小，画函数，两个数的相距距离最远即可 代码1234567891011121314151617function FindNumbersWithSum(array, sum) &#123; if (array.length &lt; 2) return []; let left = 0, right = array.length - 1; const res = []; while (left &lt; right) &#123; if (array[left] + array[right] &lt; sum) &#123; left++; &#125; else if (array[left] + array[right] &gt; sum) &#123; right--; &#125; else &#123; res.push(array[left], array[right]); break; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为s的连续正数序列]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 思路数学思路：假设序列的开始数字为a,结束数字为a+i，那么有(a+i-a+1)*(a+a+i)/2=sum只需要找到a,i就可以找到序列 代码123456789101112131415161718192021222324252627282930function FindContinuousSequence(sum) &#123; let a = 0, half = sum &gt;&gt; 1; const res = []; while (half--) &#123; a++; let i = 1; while ((i + 1) * (2 * a + i) &lt; 2 * sum) &#123; i++; &#125; if ((i + 1) * (2 * a + i) === 2 * sum) &#123; const tmp = []; tmp.push(a); tmp.push(i); res.push(tmp); &#125; &#125; for (let i = 0; i &lt; res.length; i++) &#123; let num = res[i][1], k = 1; const tmp = []; tmp.push(res[i][0]); while (num--) &#123; tmp.push(res[i][0] + k); k++; &#125; res[i] = tmp; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中只出现一次的数]]></title>
    <url>%2F2019%2F05%2F06%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路使用map记录下每个数的次数，占空间。 代码123456789101112131415161718function FindNumsAppearOnce(array) &#123; const map = &#123;&#125;, res = []; for (let i = 0; i &lt; array.length; i++) &#123; if (!map[array[i]]) &#123; map[array[i]] = 1; &#125; else &#123; map[array[i]]++; &#125; &#125; for (let i = 0; i &lt; array.length; i++) &#123; if (map[array[i]] === 1) &#123; res.push(array[i]); &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目输入一棵二叉树，判断该二叉树是否是平衡二叉树。 思路递归判断左右子树相差为多少 代码123456789101112function IsBalanced_Solution(pRoot) &#123; if (pRoot == null) return true; let leftLen = TreeDepth(pRoot.left); let rightLen = TreeDepth(pRoot.right); return Math.abs(rightLen - leftLen) &lt;= 1 &amp;&amp; IsBalanced_Solution(pRoot.left) &amp;&amp; IsBalanced_Solution(pRoot.right);&#125;function TreeDepth(pRoot) &#123; if (pRoot == null) return 0; let leftLen = TreeDepth(pRoot.left); let rightLen = TreeDepth(pRoot.right); return Math.max(leftLen, rightLen) + 1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解call、apply]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3call%E3%80%81apply%2F</url>
    <content type="text"><![CDATA[call的概念1call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 例如123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 注意两点： 1.call 改变了 this 的指向，指向到 foo 2.bar 函数执行了 模拟第一版 12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;;foo.bar(); // 1 然而添加了新的属性，所以还需删除新方法实现结果如下123456789101112131415161718// 第一版Function.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call2(foo); // 1 模拟最终版本1.函数具有返回值2.this 参数可以传 null，当为 null 的时候，视为指向 window 实现方法如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125;// 测试一下var value = 2;var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call2(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 同理实现apply12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; 参考链接]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript基础</tag>
        <tag>上下文this相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的深度]]></title>
    <url>%2F2019%2F05%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路递归遍历二叉树的深度为左右子树深度大的那一个 代码123456function TreeDepth(pRoot) &#123; if (pRoot === null) return 0; const leftDep = TreeDepth(pRoot.left); const rightDep = TreeDepth(pRoot.right); return Math.max(leftDep, rightDep) + 1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字在排序数组中出现的次数]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目统计一个数字在排序数组中出现的次数。 思路二分查找找到数字开始的位置和数字结束的位置，然后相减 代码12345678910111213141516171819202122232425262728293031323334function GetNumberOfK(data, k) &#123; if (getEnd(data, k) === -1 &amp;&amp; getBegin(data, k) === -1) return 0; return getEnd(data, k) - getBegin(data, k) + 1;&#125;function getBegin(data, k) &#123; let [left, right] = [0, data.length - 1]; let mid = left + right &gt;&gt; 1; while (left &lt;= right) &#123; if (data[mid] &gt; k) &#123; right = mid - 1; &#125; else if (data[mid] &lt; k) &#123; left = mid + 1; &#125; else if (mid - 1 &gt;= 0 &amp;&amp; data[mid - 1] === k) &#123; right = mid - 1; &#125; else return mid; mid = left + right &gt;&gt; 1; &#125; return -1;&#125;function getEnd(data, k) &#123; let [left, right] = [0, data.length - 1]; let mid = left + right &gt;&gt; 1; while (left &lt;= right) &#123; if (data[mid] &gt; k) &#123; right = mid - 1; &#125; else if (data[mid] &lt; k) &#123; left = mid + 1; &#125; else if (mid + 1 &lt; data.length &amp;&amp; data[mid + 1] === k) &#123; left = mid + 1; &#125; else return mid; mid = left + right &gt;&gt; 1; &#125; return -1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两链表的公共节点]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%B8%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目输入两个链表，找出它们的第一个公共结点。 思路快慢指针 代码1234567891011121314151617181920212223242526272829303132function FindFirstCommonNode(pHead1, pHead2) &#123; const len1 = getLinkLength(pHead1), len2 = getLinkLength(pHead2); let pLong = pHead1, pShort = pHead2, lenGap = len1 - len2; if (len1 &lt; len2) &#123; pLong = pHead2; pShort = pHead1; lenGap = len2 - len1; &#125; while (lenGap--) &#123; pLong = pLong.next; &#125; while (pLong !== null) &#123; // pLong,pShort一起跑 if (pLong.val === pShort.val) &#123; return pLong; &#125; pLong = pLong.next; pShort = pShort.next; &#125; return null;&#125;function getLinkLength(pHead) &#123; let length = 0; while (pHead !== null) &#123; pHead = pHead.next; length++; &#125; return length;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中的逆序对]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 思路归并排序的思路 先把数组分隔成子数组， 先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。 代码1234567891011121314151617181920212223242526272829function InversePairs(data) &#123; if (!data || data.length &lt; 2) return 0; const copy = data.slice(); let count = 0; count = mergeCount(data, copy, 0, data.length - 1); return count % 1000000007;&#125;function mergeCount(data, copy, start, end) &#123; if (start === end) return 0; const mid = end - start &gt;&gt; 1, left = mergeCount(copy, data, start, start + mid), // 注意参数，copy作为data传入 right = mergeCount(copy, data, start + mid + 1, end); // 注意参数，copy作为data传入 let [p, q, count, copyIndex] = [start + mid, end, 0, end]; while (p &gt;= start &amp;&amp; q &gt;= start + mid + 1) &#123; if (data[p] &gt; data[q]) &#123; copy[copyIndex--] = data[p--]; count = count + q - start - mid; &#125; else &#123; copy[copyIndex--] = data[q--]; &#125; &#125; while (p &gt;= start) &#123; copy[copyIndex--] = data[p--]; &#125; while (q &gt;= start + mid + 1) &#123; copy[copyIndex--] = data[q--]; &#125; return count + left + right;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个只出现一次的字符]]></title>
    <url>%2F2019%2F05%2F01%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置 思路使用map来记录字符出现的次数即可 代码1234567891011121314151617function FirstNotRepeatingChar(str) &#123; if (str.length &lt; 1 || str.length &gt; 10000) return -1; const map = &#123;&#125;; for (let i = 0; i &lt; str.length; i++) &#123; if (!map[str[i]]) &#123; map[str[i]] = 1;//未出现过则map次数为1 &#125; else &#123; map[str[i]]++;//出现过则次数在加一 &#125; &#125; for (let i = 0; i &lt; str.length; i++) &#123; if (map[str[i]] === 1) &#123; return i;//找到出现次数第一个为一的字符 &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丑数]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路动态规划 把前面的丑数存着，生成后面的丑数。t2,t3,t5是判断点，用于判断从何处开始选出并乘以对应因子肯定会大于当前数组中最大丑数，而前面的丑数不用考虑。 代码123456789101112function GetUglyNumber_Solution(index) &#123; if (index === 0) return 0; var uglyNum = [1]; var factor2 = 0, factor3 = 0, factor5 = 0; for (var i = 1; i &lt; index; i++) &#123; uglyNum[i] = Math.min(uglyNum[factor2] * 2, uglyNum[factor3] * 3, uglyNum[factor5] * 5); if (uglyNum[i] === uglyNum[factor2] * 2) factor2++; if (uglyNum[i] === uglyNum[factor3] * 3) factor3++; if (uglyNum[i] === uglyNum[factor5] * 5) factor5++; &#125; return uglyNum[index - 1];&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾经的博客地址]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%9B%BE%E7%BB%8F%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[博客地址]]></content>
      <categories>
        <category>以前的博客</category>
      </categories>
  </entry>
</search>
